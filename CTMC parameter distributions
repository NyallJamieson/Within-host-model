# Code for obtaining distributions for each parameter to be used within the CTMC model.

l <- read.csv("lambda_data.csv",header=FALSE)
time <- l[,2]
prop <- l[,1]
pred_frame <- seq(1,72,by=1)
pred_frame <- data.frame(pred_frame)
death_prop <- prop/100
death_cdf <- death_prop/death_prop[72]
pburrNEW <- function(x,a,b,T){(1+(T/x)^(a)*exp((T-x)/b))^(-1)}

# Lambda
####################################################
# ci for lambda is obtained by method called non-parametric bootsrapping
part1 <- function(y){
u <- runif(n=1000)
samp <- c()
for (i in u){
val <- uniroot(function(x) pburrNEW(x,a=0.6327,b=11.0200,T=21.7964)-i,lower=0,upper=500)$root
samp <- append(samp,val)
}
return(unname(1/quantile(samp,probs=0.5/death_prop[72])))
}
lambda_dist <- as.numeric(parallel::mclapply(1:10000,part1,mc.cores=parallel::detectCores()))
####################################################


# Include T to finalise
####################################################
time <- c(2,24,48,72)
dose <- c(13584.15,588828.58,11207102.05,82907236.06)
L0 <- 10^6
yourdata2 <- data.frame(time,dose)
# Now stick in other parameters (also calculate theta, x1, C, T)

results <- data.frame(matrix(ncol = 6, nrow = 0))
colnames(results) <- c("alpha_dist","beta_dist","G_dist","h_dist","A_dist","w_dist")


part2 <- function(y){
h <- sample(size=1,lambda_dist,replace=TRUE)
A_w <- MASS::mvrnorm(n=1,mu=c(177.95295,0.19242),Sigma=matrix(c(82.49019097,-0.0254690939,-0.0254690939,0.0001933546),2,2))
A <- A_w[1]
w <- A_w[2]
G <- A/(1+(A-1)*exp(-w*(1/h-1)))

reps <- 500
b <- minpack.lm::nlsLM(logdose~log(L0)+log(0.5*(h-alpha-beta+((h-alpha-beta)^2+4*h*alpha*G)^0.5))-log(((h-alpha-beta)^2+4*h*alpha*G)^0.5)-0.5*time*(h+alpha+beta-((h-alpha-beta)^2+4*h*alpha*G)^0.5),data=yourdata2,algorithm="port",start=list(alpha=0.2,beta=0.2),lower=c(0,0),control = nls.control(maxiter = 1000))
alpha_beta <- data.frame(MASS::mvrnorm(n=reps,mu=c(coef(b)[1],coef(b)[2]),Sigma=matrix(c(vcov(b)[1],vcov(b)[2],vcov(b)[3],vcov(b)[4]),2,2)))
#ab2 <- alpha_beta |> dplyr::filter(ab[,1]>0 & ab[,2]>0)


alpha_dist <- ab2[,1]
beta_dist <- ab2[,2]
G_dist <- rep(G,reps)
h_dist <- rep(h,reps)
A_dist <- rep(A,reps)
w_dist <- rep(w,reps)
return(data.frame(alpha_dist,beta_dist,G_dist,h_dist,A_dist,w_dist))
}

results <- dplyr::bind_rows(results,as.data.frame(na.omit(do.call(rbind,parallel::mclapply(1:10000,part2,mc.cores=parallel::detectCores())),na.action="omit")))
######################################################
# remove dodgy results and save
alpha_dist <- results[,1]
beta_dist <- results[,2]
int1 <- which(alpha_dist>0)
int2 <- which(beta_dist>0)
int3 <- intersect(int1,int2)

results <- results[int3,]
######################################################
# this is to repeat all rows so that we can sample C 100 times from normal distribution to incorporate uncertainty
Repeated <- results |> dplyr::slice(rep(1:nrow(results), each = 500))

alpha <- results[,1]
beta <- results[,2]
G <- results[,3]
h <- results[,4]
theta <- sqrt((h-alpha-beta)^2+4*h*alpha*G)
x1 <- 0.5*(-h-alpha-beta+theta)


dose <- c(4*10^5,4*10^5,4*10^5,4*10^5,4*10^5,4*10^5,4*10^5,4*10^5,4*10^5,4*10^5,4*10^5,4*10^5,5*10^4,5*10^4,5*10^4,5*10^4,4*10^3,4*10^3,4*10^3,4*10^3,4*10^3,4*10^3,4*10^3,4*10^3,4*10^3,4*10^3,2*10^2,2*10^2,2*10^2,2*10^2,2*10^2,2*10^2,2*10^2,2*10^2,2*10^2,2*10^2)
time <- 24*c(1,1,1,1,1,1,1,1,1,2,2,2,1,2,2,2,1,1,2,2,2,2,2,2,2,3,3,3,3,3,3,4,4,4,4,4)
yourdata3 <- data.frame(time,dose)


part3 <- function(y){
c <- nls(time~C-log(dose)/x1[y],data=yourdata3,start=list(C=100))
return(rnorm(n=500,mean=coef(c),sd=summary(c)$coefficients[,"Std. Error"]))
}
C <- unlist(parallel::mclapply(1:length(x1),part3,mc.cores=parallel::detectCores()))

Repeated <- Repeated |> tidyr::drop_na()
Repeated <- Repeated |> dplyr::mutate("C"=C[which(!is.na(C))])
results2 <- Repeated |> dplyr::filter(C>0)

theta <- sqrt((results2[,4]-results2[,1]-results2[,2])^2+4*results2[,4]*results2[,1]*results2[,3])
x1 <- 0.5*(-results2[,4]-results2[,1]-results2[,2]+theta)
phi <- rbeta(n=nrow(results2),shape=191.18,shape2=577.26)
T <- phi*(x1+results2[,4])*exp(results2[,7]*x1)/theta

results2 <- results2 |> dplyr::mutate("phi"=phi)
results2 <- results2 |> dplyr::mutate("T"=T)
results2 <- results2 |> tidyr::drop_na()
